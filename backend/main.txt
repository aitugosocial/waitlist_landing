
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr
from datetime import datetime
import os
from dotenv import load_dotenv
import psycopg2
from psycopg2.extras import RealDictCursor
from contextlib import contextmanager

# Load environment variables
load_dotenv()

app = FastAPI(title="Waitlist API")

# CORS configuration - allow your frontend to access the API
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://localhost:3000", "http://127.0.0.1:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Database configuration
DATABASE_URL = os.getenv("VITE_DATABASE_URL")

@contextmanager
def get_db_connection():
    """Context manager for database connections"""
    conn = psycopg2.connect(DATABASE_URL)
    try:
        yield conn
        conn.commit()
    except Exception as e:
        conn.rollback()
        raise e
    finally:
        conn.close()

# Pydantic models
class EmailSubmission(BaseModel):
    email: EmailStr

class WaitlistResponse(BaseModel):
    success: bool
    message: str
    data: dict = None

# Initialize database table on startup
@app.on_event("startup")
async def startup_event():
    """Create the waitlist table if it doesn't exist"""
    with get_db_connection() as conn:
        with conn.cursor() as cur:
            # Drop and recreate table to ensure proper schema
            cur.execute("""
                CREATE TABLE IF NOT EXISTS waitlist (
                    id SERIAL PRIMARY KEY,
                    email VARCHAR(255) UNIQUE NOT NULL,
                    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
            """)
    print("âœ… Database initialized successfully")

@app.get("/")
async def root():
    """Health check endpoint"""
    return {"status": "ok", "message": "Waitlist API is running"}

@app.post("/api/waitlist", response_model=WaitlistResponse)
async def add_to_waitlist(submission: EmailSubmission):
    """Add an email to the waitlist"""
    try:
        with get_db_connection() as conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                # Check if email already exists
                cur.execute("SELECT email FROM waitlist WHERE email = %s", (submission.email,))
                existing = cur.fetchone()
                
                if existing:
                    return WaitlistResponse(
                        success=False,
                        message="This email has already been registered!",
                        data={"email": submission.email}
                    )
                
                # Insert new email with explicit timestamp
                cur.execute(
                    "INSERT INTO waitlist (email, created_at) VALUES (%s, %s) RETURNING id, email, created_at",
                    (submission.email, datetime.now())
                )
                result = cur.fetchone()
                
                return WaitlistResponse(
                    success=True,
                    message="ðŸŽ‰ You've been added to the waitlist!",
                    data={
                        "id": result["id"],
                        "email": result["email"],
                        "created_at": result["created_at"].isoformat()
                    }
                )
    except Exception as e:
        print(f"Error adding to waitlist: {e}")
        raise HTTPException(status_code=500, detail="Failed to add email to waitlist")

@app.get("/api/waitlist/count")
async def get_waitlist_count():
    """Get the total number of emails in the waitlist"""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as cur:
                cur.execute("SELECT COUNT(*) FROM waitlist")
                count = cur.fetchone()[0]
                return {"count": count}
    except Exception as e:
        print(f"Error getting waitlist count: {e}")
        raise HTTPException(status_code=500, detail="Failed to get waitlist count")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
